<!DOCTYPE html>
<html>
<head>
</head>
<body style="font-family: verdana, sans-serif;font-size: 12px;">
<p>Run this simple Python threaded program. All it does is create a whole bunch of threads, each of which increments a global variable, x, a lot of times.</p>
<p>In theary the final value of x&nbsp;<em>should</em> be A * B. If you actually get that, try using larger values for A and B. If the program takes too long on your computer, try smaller values for A and B.</p>
<pre>import threading<br /><br />A = 100     # number of child threads<br />B = 100000  # number of increments per thread<br /><br /># the shared variable<br />x = 0<br /><br />def increment():<br />    # If we want to modify a global variable from inside<br />    # a function, we have to add a special declaration for it.<br />    global x     <br />    x = x + 1<br /><br />class MyThread(threading.Thread):<br />    def run(self):<br />        for i in range(B):<br />            increment()<br /><br />threads = []<br />for i in range(A):<br />    t = MyThread()<br />    t.start()<br />    threads.append(t)<br /><br /># Wait for all the threads to complete. The .join() method instructs the calling thread <br /># (the main program thread) to block until the target thread (t) completes. This loop<br /># effectively makes the main program thread block until all child threads are complete.<br />for t in threads:<br />    t.join()<br /><br />print("Done. Final value of x:", x)</pre>
<p>Most of the time you should see a value smaller than A * B. Why is that? Can you fix it?</p>
<p>Watch for more posts for answers! HINT: look up threading.Lock(). This is relevant for Lab 4!!</p>
</body>
</html>